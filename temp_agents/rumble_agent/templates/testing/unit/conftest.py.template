"""
Pytest configuration file with fixtures for testing.
Generated by Rumble.
"""

import os
import pytest
{{#pytest_mock}}
from pytest_mock import MockerFixture
{{/pytest_mock}}
{{#database}}
import tempfile
{{#sqlalchemy}}
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, clear_mappers
{{/sqlalchemy}}
{{#django}}
import django
from django.conf import settings
from django.test import Client
{{/django}}
{{#flask}}
from flask import Flask
from flask.testing import FlaskClient
{{/flask}}
{{#fastapi}}
from fastapi.testclient import TestClient
{{/fastapi}}
{{/database}}
{{#api_testing}}
import requests
import responses
{{/api_testing}}
{{#async_testing}}
import asyncio
{{/async_testing}}

{{#env_vars}}
@pytest.fixture(scope="session", autouse=True)
def setup_test_environment():
    """Set up test environment variables before tests run."""
    # Store original environment variables
    original_env = {}
    for key in [{{#env_var_keys}}"{{.}}", {{/env_var_keys}}]:
        original_env[key] = os.environ.get(key)
    
    # Set test environment variables
    {{#env_var_pairs}}
    os.environ["{{key}}"] = "{{value}}"
    {{/env_var_pairs}}
    
    yield
    
    # Restore original environment variables
    for key, value in original_env.items():
        if value is None:
            if key in os.environ:
                del os.environ[key]
        else:
            os.environ[key] = value
{{/env_vars}}

{{#database}}
{{#sqlalchemy}}
@pytest.fixture(scope="function")
def db_engine():
    """Create a SQLAlchemy engine for testing."""
    # Use in-memory SQLite database for testing
    engine = create_engine("sqlite:///:memory:")
    
    # Import models and create tables
    from {{app_name}}.models import Base
    Base.metadata.create_all(engine)
    
    yield engine
    
    # Clean up
    Base.metadata.drop_all(engine)
    clear_mappers()

@pytest.fixture(scope="function")
def db_session(db_engine):
    """Create a SQLAlchemy session for testing."""
    Session = sessionmaker(bind=db_engine)
    session = Session()
    
    yield session
    
    # Clean up
    session.rollback()
    session.close()
{{/sqlalchemy}}

{{#django}}
@pytest.fixture(scope="session", autouse=True)
def django_setup():
    """Set up Django test environment."""
    os.environ["DJANGO_SETTINGS_MODULE"] = "{{django_settings_module}}"
    django.setup()

@pytest.fixture(scope="function")
def django_db_setup(django_db_setup, django_db_blocker):
    """Set up Django database for testing."""
    with django_db_blocker.unblock():
        # Add any initial data setup here
        pass
    
    yield

@pytest.fixture(scope="function")
def django_client():
    """Create a Django test client."""
    return Client()
{{/django}}

{{#flask}}
@pytest.fixture(scope="function")
def app():
    """Create a Flask app for testing."""
    from {{app_name}} import create_app
    
    app = create_app({
        "TESTING": True,
        "DATABASE": ":memory:",
        {{#flask_config}}
        "{{key}}": {{value}},
        {{/flask_config}}
    })
    
    # Create database tables
    with app.app_context():
        from {{app_name}}.models import db
        db.create_all()
    
    yield app
    
    # Clean up
    with app.app_context():
        from {{app_name}}.models import db
        db.drop_all()

@pytest.fixture(scope="function")
def client(app):
    """Create a Flask test client."""
    return app.test_client()

@pytest.fixture(scope="function")
def runner(app):
    """Create a Flask CLI test runner."""
    return app.test_cli_runner()
{{/flask}}

{{#fastapi}}
@pytest.fixture(scope="function")
def app():
    """Create a FastAPI app for testing."""
    from {{app_name}}.main import app
    
    # Override app settings for testing
    app.dependency_overrides = {}
    
    return app

@pytest.fixture(scope="function")
def client(app):
    """Create a FastAPI test client."""
    return TestClient(app)
{{/fastapi}}
{{/database}}

{{#api_testing}}
@pytest.fixture(scope="function")
def mock_api_responses():
    """Mock external API responses."""
    with responses.RequestsMock() as rsps:
        # Add mock responses for external APIs
        {{#api_mocks}}
        rsps.add(
            responses.{{method}},
            "{{url}}",
            json={{response_json}},
            status={{status_code}}
        )
        {{/api_mocks}}
        
        yield rsps

@pytest.fixture(scope="function")
def api_client():
    """Create a requests session for API testing."""
    session = requests.Session()
    
    yield session
    
    # Clean up
    session.close()
{{/api_testing}}

{{#async_testing}}
@pytest.fixture(scope="function")
def event_loop():
    """Create an asyncio event loop for testing."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()
{{/async_testing}}

{{#auth_testing}}
@pytest.fixture(scope="function")
def auth_headers():
    """Create authentication headers for testing."""
    # Generate test token
    {{#jwt}}
    import jwt
    import time
    
    payload = {
        "sub": "test-user",
        "name": "Test User",
        "iat": int(time.time()),
        "exp": int(time.time()) + 3600,
        {{#jwt_claims}}
        "{{key}}": "{{value}}",
        {{/jwt_claims}}
    }
    
    token = jwt.encode(
        payload,
        "test-secret-key",
        algorithm="HS256"
    )
    
    return {"Authorization": f"Bearer {token}"}
    {{/jwt}}
    {{^jwt}}
    return {"Authorization": "Bearer test-token"}
    {{/jwt}}
{{/auth_testing}}

{{#mocking}}
@pytest.fixture(scope="function")
def mock_dependencies(mocker: MockerFixture):
    """Mock dependencies for testing."""
    # Add mock objects for dependencies
    {{#mock_objects}}
    mock_{{name}} = mocker.patch("{{module_path}}.{{class_name}}")
    {{#mock_methods}}
    mock_{{name}}.{{method_name}}.{{return_type}}({{return_value}})
    {{/mock_methods}}
    {{/mock_objects}}
    
    return {
        {{#mock_objects}}
        "{{name}}": mock_{{name}},
        {{/mock_objects}}
    }
{{/mocking}}

{{#custom_fixtures}}
@pytest.fixture(scope="{{scope}}")
def {{name}}({{dependencies}}):
    """{{description}}"""
    {{code}}
    
    yield {{yield_value}}
    
    {{teardown}}
{{/custom_fixtures}}
