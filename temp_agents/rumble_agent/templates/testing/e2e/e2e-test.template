{{#typescript}}
import { test, expect } from '@playwright/test';
{{#page_objects}}
import { {{page_name}}Page } from '../page-objects/{{page_name_kebab}}.page';
{{/page_objects}}

/**
 * End-to-end test for {{feature_name}}
 * 
 * This test verifies the complete user flow for {{feature_name}}
 * across multiple pages and components.
 * 
 * Generated by Rumble
 */

test.describe('{{feature_name}} E2E Tests', () => {
  {{#page_objects}}
  let {{page_name_camel}}Page: {{page_name}}Page;
  {{/page_objects}}
  
  test.beforeEach(async ({ page }) => {
    // Navigate to the application
    await page.goto('{{base_url}}');
    
    {{#page_objects}}
    // Initialize page objects
    {{page_name_camel}}Page = new {{page_name}}Page(page);
    {{/page_objects}}
    
    {{#auth}}
    // Log in before tests if authentication is required
    await page.goto('{{login_url}}');
    await page.fill('input[name="username"]', '{{test_username}}');
    await page.fill('input[name="password"]', '{{test_password}}');
    await page.click('button[type="submit"]');
    
    // Verify successful login
    await expect(page).toHaveURL('{{dashboard_url}}');
    {{/auth}}
  });
  
  {{#test_scenarios}}
  test('{{scenario_name}}', async ({ page }) => {
    {{#steps}}
    // {{step_description}}
    {{#navigation}}
    await page.goto('{{url}}');
    await expect(page).toHaveURL('{{url}}');
    {{/navigation}}
    
    {{#click}}
    await page.click('{{selector}}');
    {{/click}}
    
    {{#fill}}
    await page.fill('{{selector}}', '{{value}}');
    {{/fill}}
    
    {{#select}}
    await page.selectOption('{{selector}}', '{{value}}');
    {{/select}}
    
    {{#check}}
    await page.check('{{selector}}');
    {{/check}}
    
    {{#uncheck}}
    await page.uncheck('{{selector}}');
    {{/uncheck}}
    
    {{#file_upload}}
    await page.setInputFiles('{{selector}}', '{{file_path}}');
    {{/file_upload}}
    
    {{#hover}}
    await page.hover('{{selector}}');
    {{/hover}}
    
    {{#drag_and_drop}}
    await page.dragAndDrop('{{source_selector}}', '{{target_selector}}');
    {{/drag_and_drop}}
    
    {{#keyboard}}
    await page.keyboard.press('{{key}}');
    {{/keyboard}}
    
    {{#wait}}
    await page.waitForSelector('{{selector}}');
    {{/wait}}
    
    {{#wait_for_navigation}}
    await page.waitForNavigation();
    {{/wait_for_navigation}}
    
    {{#wait_for_timeout}}
    await page.waitForTimeout({{timeout}});
    {{/wait_for_timeout}}
    
    {{#screenshot}}
    await page.screenshot({ path: '{{path}}' });
    {{/screenshot}}
    
    {{#expect}}
    {{#visible}}
    await expect(page.locator('{{selector}}')).toBeVisible();
    {{/visible}}
    
    {{#hidden}}
    await expect(page.locator('{{selector}}')).toBeHidden();
    {{/hidden}}
    
    {{#enabled}}
    await expect(page.locator('{{selector}}')).toBeEnabled();
    {{/enabled}}
    
    {{#disabled}}
    await expect(page.locator('{{selector}}')).toBeDisabled();
    {{/disabled}}
    
    {{#checked}}
    await expect(page.locator('{{selector}}')).toBeChecked();
    {{/checked}}
    
    {{#text}}
    await expect(page.locator('{{selector}}')).toHaveText('{{text}}');
    {{/text}}
    
    {{#value}}
    await expect(page.locator('{{selector}}')).toHaveValue('{{value}}');
    {{/value}}
    
    {{#attribute}}
    await expect(page.locator('{{selector}}')).toHaveAttribute('{{attribute}}', '{{value}}');
    {{/attribute}}
    
    {{#url}}
    await expect(page).toHaveURL('{{url}}');
    {{/url}}
    
    {{#title}}
    await expect(page).toHaveTitle('{{title}}');
    {{/title}}
    
    {{#count}}
    await expect(page.locator('{{selector}}')).toHaveCount({{count}});
    {{/count}}
    {{/expect}}
    
    {{#page_object}}
    // Use page object methods
    await {{page_name_camel}}Page.{{method}}({{args}});
    {{/page_object}}
    {{/steps}}
  });
  {{/test_scenarios}}
  
  {{#visual_regression}}
  test('Visual regression test for {{feature_name}}', async ({ page }) => {
    // Navigate to the feature page
    await page.goto('{{feature_url}}');
    
    // Take a screenshot for visual comparison
    await expect(page).toHaveScreenshot('{{feature_name_kebab}}.png', {
      maxDiffPixelRatio: 0.05
    });
    
    {{#responsive}}
    // Test responsive layouts
    const viewports = [
      { width: 1920, height: 1080, name: 'desktop' },
      { width: 1024, height: 768, name: 'tablet' },
      { width: 375, height: 667, name: 'mobile' }
    ];
    
    for (const viewport of viewports) {
      await page.setViewportSize({ width: viewport.width, height: viewport.height });
      await expect(page).toHaveScreenshot(`{{feature_name_kebab}}-${viewport.name}.png`, {
        maxDiffPixelRatio: 0.05
      });
    }
    {{/responsive}}
  });
  {{/visual_regression}}
  
  {{#performance}}
  test('Performance test for {{feature_name}}', async ({ page }) => {
    // Enable performance metrics
    await page.evaluate(() => {
      window.performance.mark('test-start');
    });
    
    // Navigate to the feature page
    await page.goto('{{feature_url}}');
    
    // Wait for the page to be fully loaded
    await page.waitForLoadState('networkidle');
    
    // Measure performance
    const metrics = await page.evaluate(() => {
      window.performance.mark('test-end');
      window.performance.measure('test-duration', 'test-start', 'test-end');
      
      const navigationTiming = performance.getEntriesByType('navigation')[0];
      const paintTiming = performance.getEntriesByType('paint');
      const resourceTiming = performance.getEntriesByType('resource');
      
      return {
        navigationTiming,
        paintTiming,
        resourceCount: resourceTiming.length,
        testDuration: performance.getEntriesByName('test-duration')[0].duration
      };
    });
    
    // Assert on performance metrics
    expect(metrics.testDuration).toBeLessThan({{max_duration}});
    console.log('Performance metrics:', metrics);
  });
  {{/performance}}
  
  {{#accessibility}}
  test('Accessibility test for {{feature_name}}', async ({ page }) => {
    // Navigate to the feature page
    await page.goto('{{feature_url}}');
    
    // Run accessibility audit
    const accessibilityScanResults = await page.evaluate(() => {
      // This would typically use an accessibility testing library like axe-core
      // For this template, we're just simulating the results
      return {
        violations: [],
        passes: [],
        incomplete: [],
        inapplicable: []
      };
    });
    
    // Assert on accessibility results
    expect(accessibilityScanResults.violations.length).toBe(0);
  });
  {{/accessibility}}
});
{{/typescript}}

{{^typescript}}
const { test, expect } = require('@playwright/test');
{{#page_objects}}
const { {{page_name}}Page } = require('../page-objects/{{page_name_kebab}}.page');
{{/page_objects}}

/**
 * End-to-end test for {{feature_name}}
 * 
 * This test verifies the complete user flow for {{feature_name}}
 * across multiple pages and components.
 * 
 * Generated by Rumble
 */

test.describe('{{feature_name}} E2E Tests', () => {
  {{#page_objects}}
  let {{page_name_camel}}Page;
  {{/page_objects}}
  
  test.beforeEach(async ({ page }) => {
    // Navigate to the application
    await page.goto('{{base_url}}');
    
    {{#page_objects}}
    // Initialize page objects
    {{page_name_camel}}Page = new {{page_name}}Page(page);
    {{/page_objects}}
    
    {{#auth}}
    // Log in before tests if authentication is required
    await page.goto('{{login_url}}');
    await page.fill('input[name="username"]', '{{test_username}}');
    await page.fill('input[name="password"]', '{{test_password}}');
    await page.click('button[type="submit"]');
    
    // Verify successful login
    await expect(page).toHaveURL('{{dashboard_url}}');
    {{/auth}}
  });
  
  {{#test_scenarios}}
  test('{{scenario_name}}', async ({ page }) => {
    {{#steps}}
    // {{step_description}}
    {{#navigation}}
    await page.goto('{{url}}');
    await expect(page).toHaveURL('{{url}}');
    {{/navigation}}
    
    {{#click}}
    await page.click('{{selector}}');
    {{/click}}
    
    {{#fill}}
    await page.fill('{{selector}}', '{{value}}');
    {{/fill}}
    
    {{#select}}
    await page.selectOption('{{selector}}', '{{value}}');
    {{/select}}
    
    {{#check}}
    await page.check('{{selector}}');
    {{/check}}
    
    {{#uncheck}}
    await page.uncheck('{{selector}}');
    {{/uncheck}}
    
    {{#file_upload}}
    await page.setInputFiles('{{selector}}', '{{file_path}}');
    {{/file_upload}}
    
    {{#hover}}
    await page.hover('{{selector}}');
    {{/hover}}
    
    {{#drag_and_drop}}
    await page.dragAndDrop('{{source_selector}}', '{{target_selector}}');
    {{/drag_and_drop}}
    
    {{#keyboard}}
    await page.keyboard.press('{{key}}');
    {{/keyboard}}
    
    {{#wait}}
    await page.waitForSelector('{{selector}}');
    {{/wait}}
    
    {{#wait_for_navigation}}
    await page.waitForNavigation();
    {{/wait_for_navigation}}
    
    {{#wait_for_timeout}}
    await page.waitForTimeout({{timeout}});
    {{/wait_for_timeout}}
    
    {{#screenshot}}
    await page.screenshot({ path: '{{path}}' });
    {{/screenshot}}
    
    {{#expect}}
    {{#visible}}
    await expect(page.locator('{{selector}}')).toBeVisible();
    {{/visible}}
    
    {{#hidden}}
    await expect(page.locator('{{selector}}')).toBeHidden();
    {{/hidden}}
    
    {{#enabled}}
    await expect(page.locator('{{selector}}')).toBeEnabled();
    {{/enabled}}
    
    {{#disabled}}
    await expect(page.locator('{{selector}}')).toBeDisabled();
    {{/disabled}}
    
    {{#checked}}
    await expect(page.locator('{{selector}}')).toBeChecked();
    {{/checked}}
    
    {{#text}}
    await expect(page.locator('{{selector}}')).toHaveText('{{text}}');
    {{/text}}
    
    {{#value}}
    await expect(page.locator('{{selector}}')).toHaveValue('{{value}}');
    {{/value}}
    
    {{#attribute}}
    await expect(page.locator('{{selector}}')).toHaveAttribute('{{attribute}}', '{{value}}');
    {{/attribute}}
    
    {{#url}}
    await expect(page).toHaveURL('{{url}}');
    {{/url}}
    
    {{#title}}
    await expect(page).toHaveTitle('{{title}}');
    {{/title}}
    
    {{#count}}
    await expect(page.locator('{{selector}}')).toHaveCount({{count}});
    {{/count}}
    {{/expect}}
    
    {{#page_object}}
    // Use page object methods
    await {{page_name_camel}}Page.{{method}}({{args}});
    {{/page_object}}
    {{/steps}}
  });
  {{/test_scenarios}}
  
  {{#visual_regression}}
  test('Visual regression test for {{feature_name}}', async ({ page }) => {
    // Navigate to the feature page
    await page.goto('{{feature_url}}');
    
    // Take a screenshot for visual comparison
    await expect(page).toHaveScreenshot('{{feature_name_kebab}}.png', {
      maxDiffPixelRatio: 0.05
    });
    
    {{#responsive}}
    // Test responsive layouts
    const viewports = [
      { width: 1920, height: 1080, name: 'desktop' },
      { width: 1024, height: 768, name: 'tablet' },
      { width: 375, height: 667, name: 'mobile' }
    ];
    
    for (const viewport of viewports) {
      await page.setViewportSize({ width: viewport.width, height: viewport.height });
      await expect(page).toHaveScreenshot(`{{feature_name_kebab}}-${viewport.name}.png`, {
        maxDiffPixelRatio: 0.05
      });
    }
    {{/responsive}}
  });
  {{/visual_regression}}
  
  {{#performance}}
  test('Performance test for {{feature_name}}', async ({ page }) => {
    // Enable performance metrics
    await page.evaluate(() => {
      window.performance.mark('test-start');
    });
    
    // Navigate to the feature page
    await page.goto('{{feature_url}}');
    
    // Wait for the page to be fully loaded
    await page.waitForLoadState('networkidle');
    
    // Measure performance
    const metrics = await page.evaluate(() => {
      window.performance.mark('test-end');
      window.performance.measure('test-duration', 'test-start', 'test-end');
      
      const navigationTiming = performance.getEntriesByType('navigation')[0];
      const paintTiming = performance.getEntriesByType('paint');
      const resourceTiming = performance.getEntriesByType('resource');
      
      return {
        navigationTiming,
        paintTiming,
        resourceCount: resourceTiming.length,
        testDuration: performance.getEntriesByName('test-duration')[0].duration
      };
    });
    
    // Assert on performance metrics
    expect(metrics.testDuration).toBeLessThan({{max_duration}});
    console.log('Performance metrics:', metrics);
  });
  {{/performance}}
  
  {{#accessibility}}
  test('Accessibility test for {{feature_name}}', async ({ page }) => {
    // Navigate to the feature page
    await page.goto('{{feature_url}}');
    
    // Run accessibility audit
    const accessibilityScanResults = await page.evaluate(() => {
      // This would typically use an accessibility testing library like axe-core
      // For this template, we're just simulating the results
      return {
        violations: [],
        passes: [],
        incomplete: [],
        inapplicable: []
      };
    });
    
    // Assert on accessibility results
    expect(accessibilityScanResults.violations.length).toBe(0);
  });
  {{/accessibility}}
});
{{/typescript}}
